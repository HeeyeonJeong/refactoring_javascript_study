## Ch.7 캡슐화

- 내부 구현 사항을 숨기고, 외부에서 필요한 사항들만 공개하는 프로그래밍 방법
- 모듈이나 함수, 클래스와 같은 형태로 캡슐화 해둔다면, 아무나 손쉽게 변수 및 데이터를 변경할 수 없게 만들 수 있고,
- 데이터를 변경하고 사용하는 유일한 통로(인터페이스)가 되어, 변경되는 과정을 감시할 수 있다.
- 모듈, 함수, 클래스 모두 한가지의 책임 및 하나의 도메인 (다루는 영역_*학생, 학교 등*)만을 가지도록 만들어야 한다. (SRP_단일책임원칙)

### 레코드

- 보통 Key와 Value로 이루어진 것을 의미
- 자바스크립트에서는 {} 객체 형태로 표현

### 컬렉션

- 복합적인 데이터를 담고 있는 것
- 배열, 리스트, Set 등과 같은 데이터를 담고있는 것(클래스)

### 불변성

- 캡슐화 리팩토링을 진행할 때, get 메서드를 구현하게 된다면 반드시 원본이 아닌 **복제본**을 리턴할 수 있도록 구현하자!
- 만약 원본을 수정하고 싶다면, set을 이용하기 보다는 **add**나 **remove** 등의 메서드를 통해 더 가시적으로 표현될 수 있도록 하자!
- 예시)
```js
const obj = { a: 1, b: 2 };

// 원본 그대로 리턴할 경우,
class OriginObj {
    #obj;
    constructor({ obj }) {
        this.#obj = obj;
    }
    get obj () {
        return this.#obj;
    }
}
// 복사본을 리턴할 경우,
class ClonedObj {
    #obj;
    constructor({ obj }) {
        this.#obj = obj;
    }
    get obj () {
        return Object.assign({}, this.#obj);
    }
}

const originObj = new OriginObj({ obj });
const clonedObj = new ClonedObj({ obj });

obj === originObj // true
obj === clonedObj // false

originObj.obj.b = 55;
console.log(obj.b); // 기존 2 => 55로 수정됨!

clonedObj.obj.b = 70;
console.log(obj.b); // 기존 b 값에서 변경이 이루어지지 않음!
```

<br />

### 7.1 레코드 캡슐화하기

- 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위함이다. 
- 클래스로 캡슐화를 진행한다면, 해당 인스턴스 객체를 거쳐야만 수정이 가능해지기 때문에, 변수나 데이터를 조작하는 방식을 쉽게 통제할 수 있게된다.
- 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한곳에 모아두는 일이 굉장히 중요하다.

<br />

### 7.2 컬렉션 캡슐화하기

- 클래스를 이용한 캡슐화를 진행할 때, get 메서드를 구현하게 된다면 반드시 원본이 아닌 **복제본**을 리턴할 수 있도록 구현해야한다.
- 만약 원본을 수정하고 싶다면, set을 이용하기 보다는 **add**나 **remove** 등의 메서드를 통해 더 가시적으로 표현될 수 있도록 해야한다.
- set을 이용해 컬렉션을 통째로 설정한 코드는 누구든지 해당 컬렉션을 마음대로 수정할 수 있게 되기 때문이다.

<br />

### 7.3 기본형을 객체로 바꾸기

- 음.. 아직은 크게 필요성을 느끼지 못하는 부분

<br />

### 7.4. 임시변수를 질의 함수로 바꾸기

- 변수는 값을 한번만 계산하고, 그 뒤로는 읽기만 해야한다.
- 그렇기 때문에 만약 변수에 값을 한번 대입한 뒤 다시 여러번 대입하는 경우가 있다면, 모두 함수로 추출해야한다!

<br />

### 7.5 클래스 추출하기

- 하나의 클래스는 하나의 도메인만을 책임져야 한다.
- 즉, 쪼갤 수 있는 도메인이라면 서브 클래스를 만들어 리팩토링을 진행하자.

<br />

### 7.6 클래스 인라인하기

- 7.5 클래스 추출하기의 반대 개념. 쪼개지 않아도 되는 클래스라면, 하나의 클래스로 합치자.

<br />

### 7.7 위임 숨기기

- 클라이언트의 입장에서 어떤 데이터를 조회하거나 수정할 때 위임(중개자) 클래스를 한번 거치는 것이 불편할 수도, 혹은 해당 위임(중개자) 클래스를 클라이언트에게 숨겨야 할 수가 있다.
- 이럴 때, 위임 숨기기 리팩토링을 통해 위임(중개자) 클래스를 숨기는, **은닉화**를 진행할 수 있다. 

<br />

### 7.8 중개자 제거하기

- 7.7 위임 숨기기의 반대 개념. 위임(중개자) 클래스의 기능이 추가될 때마다 위임 메서드를 두 클래스 모두 추가해야 하는데, 이러한 과정이 굉장히 번거로워질 수 있다.
- 7.6 클래스 인라인하기 처럼, 위임(중개자) 클래스를 제거하고 하나의 클래스에서 모두 관리하게 할 수도 있다.

<br />

### 7.9 알고리즘 교체하기

- 복잡한 알고리즘을 더 간명한 알고리즘으로 교체하는 리팩토링 기법.
- 복잡한 알고리즘을 신뢰할 수 있는 라이브러리로 대체할 수 있다면 대체하는 것이 더 현명하다!
- 이 작업에 착수하려면, 반드시 메서드를 가능한 한 잘게 나누어야 한다!