## Ch.7 캡슐화

- 내부 구현 사항을 숨기고, 외부에서 필요한 사항들만 공개하는 프로그래밍 방법
- 모듈이나 함수, 클래스와 같은 형태로 캡슐화 해둔다면, 아무나 손쉽게 변수 및 데이터를 변경할 수 없게 만들 수 있고,
- 데이터를 변경하고 사용하는 유일한 통로가 되어, 변경되는 과정을 감시할 수 있다.
- 모듈, 함수, 클래스 모두 한가지의 책임 및 하나의 도메인 (다루는 영역_*학생, 학교 등*)만을 가지도록 만들어야 한다. (SRP_단일책임원칙)

### 불변성

- 캡슐화 리팩토링을 진행할 때, get 메서드를 구현하게 된다면 반드시 원본이 아닌 **복제본**을 리턴할 수 있도록 구현하자!
- 만약 원본을 수정하고 싶다면, set을 이용하기 보다는 **add**나 **remove** 등의 메서드를 통해 더 가시적으로 표현될 수 있도록 하자!
- 예시)
```js
const obj = { a: 1, b: 2 };

// 원본 그대로 리턴할 경우,
class OriginObj {
    #obj;
    constructor({ obj }) {
        this.#obj = obj;
    }
    get obj () {
        return this.#obj;
    }
}
// 복사본을 리턴할 경우,
class ClonedObj {
    #obj;
    constructor({ obj }) {
        this.#obj = obj;
    }
    get obj () {
        return Object.assign({}, this.#obj);
    }
}

const originObj = new OriginObj({ obj });
const clonedObj = new ClonedObj({ obj });

obj === originObj // true
obj === clonedObj // false

originObj.obj.b = 55;
console.log(obj.b); // 기존 2 => 55로 수정됨!

clonedObj.obj.b = 70;
console.log(obj.b); // 기존 b 값에서 변경이 이루어지지 않음!
```

<br />

### 7.1 레코드 캡슐화하기

- 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위함이다. 
- 클래스로 캡슐화를 진행한다면, 해당 인스턴스 객체를 거쳐야만 수정이 가능해지기 때문에, 변수나 데이터를 조작하는 방식을 쉽게 통제할 수 있게된다.
- 캡슐화에서는 값을 수정하는 부분을 명확하게 드러내고 한곳에 모아두는 일이 굉장히 중요하다.

<br />

### 7.2 컬렉션 캡슐화하기

- 클래스를 이용한 캡슐화를 진행할 때, get 메서드를 구현하게 된다면 반드시 원본이 아닌 **복제본**을 리턴할 수 있도록 구현해야한다.
- 만약 원본을 수정하고 싶다면, set을 이용하기 보다는 **add**나 **remove** 등의 메서드를 통해 더 가시적으로 표현될 수 있도록 해야한다.
- set을 이용해 컬렉션을 통째로 설정한 코드는 누구든지 해당 컬렉션을 마음대로 수정할 수 있게 되기 때문이다.

<br />

### 7.3 기본형을 객체로 바꾸기

- 음.. 아직은 크게 필요성을 느끼지 못하는 부분

<br />

### 7.4. 임시변수를 질의 함수로 바꾸기

- 변수는 값을 한번만 계산하고, 그 뒤로는 읽기만 해야한다.
- 그렇기 때문에 만약 변수에 값을 한번 대입한 뒤 다시 여러번 대입하는 경우가 있다면, 모두 함수로 추출해야한다!

### 7.5 클래스 추출하기

- 하나의 클래스는 하나의 도메인만을 책임져야 한다.
- 즉, 쪼갤 수 있는 도메인이라면 서브 클래스를 만들어 리팩토링을 진행하자.