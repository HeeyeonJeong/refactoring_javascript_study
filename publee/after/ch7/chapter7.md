# Chapter7 - 캡슐화

캡슐화란? 내부 구현 사항을 숨기고, 외부에서 필요한 사항들만 공개한다.

캡슐화의 원칙

1. 함수 하나당, 한가지의 일을 수행하도록 만들어 주자
2. 모듈/클래스 하나당, 한가지의 책임 || 하나의 도메인(ex. 학생, 주문, 전화번호 등)을 가지도록 한다.

## 7-1 레코드 캡슐화하기
레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위해서이다.

## 7-2 컬렉셜 캡슐화하기
가변 데이트는 모두 캡슐화하는 것이 좋다.

캡슐화를 한다면 
데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워져 필요한시점에 데이터 구조를 변경하기도 쉬어지기 때문이다.

주의해야할 점
- 게터가 컬렉션 자체를 반환하도록 한다면 원소가 바뀔 위험성이 있어 add 또는 remove와 같은 컬렉션 변경자 메서드를 만드는 것이 안정적으로 컬렉션을 사용할 수 있다.
- 게터가 원본 컬렉션을 반환하지 않도록하여 클라이언트가 실수로 컬렉션을 바꿀 위험성을 줄이는 것도 하나의 방법이다.

## 7-3 기본형을 객체로 바꾸기
...???

## 7-4 임시 변수를 질의 함수로 바꾸기

임시변수 활용시 장점

- 값을 계산하는 코드가 반복되는 것을 줄일 수 있다.
- 변수명을 통해 의미 전달이 가능

임의 변수를 질의 함수로 바꿀시 주의사항
- 변수는 값을 한 번만 계산하고, 그 뒤로는 읽기만 하도록 한다.

## 7-5 클래스 추출하기
메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않다.
일부 데이터와 메서드를 따로 묶을 수 있다면 분리하는 것이 좋다. 또한 변경되는 일이 많거나 서로 의존하는 데이터들도 분리한다.

## 7-6 클래스 인라인하기

## 7-7 위임 숨기기
서버 객체의 필드가 가리키는 객체(위임 객체)의 메서드를 호출하려면 클라이언트는 위임 객체를 알아야한다.
위임 객체의 인터페이스가 바뀌면 위임 객체를 사용하는 모든 클라이언트의 코드들을 수정해야하는 문제가 생긴다.
이러한 의존성을 없애기 위해서 **위임 메서드를 만들어 위임 객체의 존재를 숨길 수 있다.**

## 7-8 중재자 제거하기

## 7-9 알고리즘 교체하기

