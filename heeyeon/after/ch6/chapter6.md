# ch6. 기본적인 리팩터링

### ch6/6-1

- 함수 추출하기
    - printOwing()함수에 여러 기능을 하는 함수가 들어있다. > 함수분리
    - 지역변수는 사용하는 곳과 가까운곳에서 정의
    - outStanding과 같은 변수명보단 result로 정의

### ch6/6-2

- 함수 인라인하기
    - 불필요한 함수 추출 > 함수 인라인으로 수정

### ch6/6-3

- 변수 추출하기

### ch6/6-4

- 변수 인라인하기

### ch6/6-5

- 변수 이름짓기
    - 필요한 데이터만 받아오기, 외부 다른 객체의 의존도를 낮춰서 재사용성 높이기

### ch6/6-6

- 변수 캡슐화하기
    - 내부 구현 사항을 숨기고, 외부에서 필요한 사항들만 공개
    - spread 연산자를 사용해서 복사 > 얕은 복사가 된다 >> 중첩된 객체가 있을때 위험성이 있을 수 있다.
    - Object.assign 사용
    - class 형 >> class로 사용하기 > get 만 가능하도록 한다.
    - (함수형 >> loadsh를 사용한다면, 해당 라이브러리에서 cloneDeep으로 깊은 복사를 할 수 있다.)
    

### ch6/6-7

- 변수 이름 바꾸기

### ch6/6-8

- 함수의 매개변수 > 매개변수 객체 만들기
    - 매개변수의 갯수는 최대 3개를 넘지 않는 것이 좋다
    - 연관있는 데이터 구조 하나로 묶어주기

### ch6/6-9

- 여러 함수를 클래스로 묶기 (<< 여러함수를 변환 함수로 묶기보다 효율적임)

### ch6/6-10

- 여러 함수를 변환 함수로 묶기 (<< 이전 방식)
    - loadsh 라이브러리를 사용한다면, cloneDeep으로 깊은 복사를 할 수 있다.


***


- 클래스의 get을 사용하면 데이터가 나중에 변경되어도 **변경된 데이터를 기반으로 get하는 시점에 데이터를 가지고 계산, 처리**해서 데이터를 반환
- 변환함수는 **변환함수를 호출하는 그 시점에  데이터를 가지고** 계산된 데이터가 한번 저장되고 그 뒤에 나중에 데이터가 변경되어도 업데이트 되지 않는다 > 내가 **원하는 시점의 데이터가 있다면 해당 함수를 계속 호출해야함**

데이터가 변경되는지 안되는지에 따라 변환함수의 사용을 결정하면 되지만, 간단하게 클래스를 사용하는게 좋지 않을까?


***

### ch6/6-11

- 함수 쪼개기
    - 긴함수는 유지보수, 가독성이 떨어짐, 재사용 불가